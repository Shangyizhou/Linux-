## 多线程编程

### Linux线程历史

早期Linux不支持线程，直到1996年，Xavier Leroy等人才开发出 第一个基本符合POSIX标准的线程库`LinuxThreads`（其效率低有很多问题）。

自内核2.6开始，Linux才真正提供内核级的线程支持，并有两个组织致力于编写新的线程库：`NGPT（Next Generation POSIX Threads）`和`NPTL（Native POSIX Thread Library）`。

`NGPT`2003年就被放弃了，因此新的线程库就称为`NPTL`。`NPTL`比 `LinuxThreads`效率高，且更符合`POSIX`规范，所以它已经成为`glibc`的一 部分

### POSIX线程（pthread）内容

- 创建线程和结束线程
- 读取和设置线程属性
- POSIX线程同步方式
  - POSIX信号量
  - 互斥锁
  - 条件变量。

### 线程概述

线程是程序中完成一个独立任务的完整执行序列，即一个可调度的实体

线程分内核线程和用户线程

- 内核线程（LWP：Light Weight Process， 轻量级进程）运行在内核空间，由内核来调度

- 用户线程用户线程运行在用户空间，由线程库来调度。

当进程的一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程（内核线程相当于用户线程运行的“容器”）。一个进程可以拥有M个内核线程和N个用户线程，其中 M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度（two level scheduler）。

**完全在用户空间实现的线程**



其无需内核的支持，内核甚至不知道这些线程的存在

线程库负责管理所有执行线程（线程的优先级、时间片等）

线程库利用`longjmp`来切换线程的执行，使它们看起来像是“并发”执行的，但内核仍然是把整个进程最为最小单位来调度的。**一个进程的所有执行线程共享该进程的时间片， 它们对外表现出相同的优先级。**所以该程序抢夺CPU就比较成功，其一个进程的所有执行线程都像是一个个进程一样，能抢夺时间片，最后表现出来的结果是程序执行快了不少。因此，对这种实现方式而言，M个用户空间线程对应1个内核线程，而该内核线程实际上就是进程本身。

**优点**

创建和调度线程都无须内核的干预，因此速度相当快

它不占用额外的内核资源， 所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影响。

**缺点**

对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的

线程的优先级只对同一个进程中的线程有效，比较不同进程中的 线程的优先级没有意义

**完全由内核调度的模式**

该模式将创建、调度线程的任务都交给了内核， 运行在用户空间的线程库无须执行管理任务

较早的Linux内核对线程控制不够，还需借助线程库，但是洗澡内核大大增强了对线程的支持，所以可以完全交由内核调度

完全由内核调度的这种线程实现方式满足M:N=1:1，即1个用户空间线程被映射为1个内核线程。

**双层调度模式**

双层调度模式是前两种实现模式的混合体：内核调度M个内核线程，线程库调度N个用户线程。

**优点**

不但不会消耗过多的内核资源，而且线程切换速度也较快， 同时它可以充分利用多处理器的优势

### Linux线程库

**Linux上两个最有名的线程库是LinuxThreads和NPTL，它们都是采用1:1的方式实现的。**由于LinuxThreads在开发的时候，Linux内核对线程的支持还非常有限，所以其可用性、稳定性以及POSIX兼容性都远远不及NPTL。现代Linux上默认使用的线程库是NPTL。用户可以使用如下命令来查看当前系统上所使用的线程库

**LinuxThreads线程库**

内核线程是用clone系统调用创建的进程模拟的。**clone系统调用和fork系统调用的作用类似：创建调用进程的子进程。**不过我们可以为clone系统调用指定CLONE_THREAD标志，这种情况下它创建的子进程与调用进程共享相同的虚拟地址空间、文件 描述符和信号处理函数，这些都是线程的特点。**不过，用进程来模拟内核线程会导致很多语义问题**

- 每个线程拥有不同的PID，因此不符合POSIX规范。 
- Linux信号处理本来是基于进程的，但现在一个进程内部的所有线程都能而且必须处理信号。 
- 用户ID、组ID对一个进程中的不同线程来说可能是不一样的。 
- 程序产生的核心转储文件不会包含所有线程的信息，而只包含产生该核心转储文件的线程的信息。 
- 由于每个线程都是一个进程，因此系统允许的最大进程数也就是最大线程数。 LinuxThreads线程库一个有名的特性是所谓的管理线程。它是进程中专门用于管理其他工作线程的线程。其作用包括： 
  - 系统发送给进程的终止信号先由管理线程接收，管理线程再给其他工作线程发送同样的信号以终止它们。 
  - 当终止工作线程或者工作线程主动退出时，管理线程必须等待它们结束，以避免僵尸进程。 
  - 如果主线程先于其他工作线程退出，则管理线程将阻塞它，直到所有其他工作线程都结束之后才唤醒它。 
  - 回收每个线程堆栈使用的内存。

Linux内核从 2.6版本开始，提供了真正的内核线程。新的NPTL线程库也应运而 生。相比LinuxThreads，NPTL的主要优势在于：

- 内核线程不再是一个进程，因此避免了很多用进程模拟内核线 程导致的语义问题。 
- 摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内 核来完成。 
- 由于不存在管理线程，所以一个进程的线程可以运行在不同的 CPU上，从而充分利用了多处理器系统的优势。 
- 线程的同步由内核来完成。隶属于不同进程的线程之间也能共 享互斥锁，因此可实现跨进程的线程同步。