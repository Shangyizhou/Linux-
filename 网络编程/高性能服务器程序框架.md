## 服务器模型

- C/S模型
- P2P模型

### **C/S模型**

所有客户端都通过访问服务器获得资源

逻辑简单，服务器启动，创建一个或多个socket，并调用bind函数将其绑定到服务器感兴趣的端口，然后调用listen函数等待客户连接。服务器稳定运行后，客户端就可以调用connect向服务器发起连接。



<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015175714664.png" alt="image-20211015175714664" style="zoom:67%;" />

**由于客户连接请求是随机到达的异步事件，服务器要使用某种I/O模型来监听这一事件**

I/O模型有多种，下图使用的是I/O复用技术之一的select系统调用，监听到连接请求，服务器调用accept接收连接，并创建一个新的进程作为逻辑单元去接受新的连接。

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015175730518.png" alt="image-20211015175730518" style="zoom:67%;" />

**优点**

C/S模型非常适合资源相对集中的场合

实现简单

**缺点**

服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应

### **P2P模型**

**问题**

服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应

服务器之间很难相互发现，所以添加一个**发现服务器**，用于提供查找服务

![image-20211015180725559](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015180725559.png)

从编程角度来讲，P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器。

## 服务器编程框架

服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理

**我们先看基本框架**

![image-20211015180947707](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015180947707.png)

该图既能用来描述一台服务器，也能用来描述一个服务器机群

| 模块         | 单个服务器程序             | 服务器机群                   |
| :----------- | :------------------------- | :--------------------------- |
| I/O处理单元  | 处理客户连接，读写网络数据 | 作为接入服务器，实现负载均衡 |
| 逻辑单元     | 业务进程或线程             | 逻辑服务器                   |
| 网络存储单元 | 本地数据库、文件或缓冲     | 数据库服务器                 |
| 请求队列     | 各单元之间的通信方式       | 各服务器之间的永久TCP连接    |

**I/O处理单元**

等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。

数据的收发不一定在I/O处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式

**逻辑单元**

通常是一个进程或线程，分析并处理客户数据， 然后将结果传递给I/O处理单元或者直接发送给客户端

**网络存储单元**

可以是数据库、缓存和文件，甚至是一台独立的服 务器。但它不是必须的

**请求队列**

各单元之间的通信方式的抽象

## I/O模型

我们称阻塞的文件描述符为阻塞I/O，非阻塞的文件描述符为非阻塞I/O

**阻塞I/O**

**针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止**

比如，客户端通过connect向服务器请求连接，服务器应返回确认报文，在没返回期间，connect挂起（类似的有accept，send，recv）

**非阻塞I/O**

**针对非阻塞I/O执行的系统调用则总是立即返回（错误也返回，可以循环询问是否准备好数据），而不管事件是否已经发生。**

我们的I/O阻塞了，挂起等待会浪费效率。显然，我们只有在事件已经发生的情况下操作非阻塞I/O才可以提升程序效率。

**I/O复用**

最常使用的I/O通知机制，应用程序通过I/O 复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。（select、poll、epoll，epoll_wait）

I/O复用函数本身是阻塞的（select），它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。

**SIGIO信号**

我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO 信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对 目标文件描述符执行非阻塞I/O操作了。

**异步I/O**

对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。**异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。**

**同步I/O向应用程序通知的是I/O就绪事件， 而异步I/O向应用程序通知的是I/O完成事件。**

![image-20211015224847918](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015224847918.png)

## 同步IO与异步IO区别

同步IO：在一个线程中，CPU执行代码的速度极快，然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。IO期间CPU会转去执行其他线程。

异步IO：当遇到IO操作时，CPU只是发送IO指令，不等待结果，然后继续执行其他代码。一段时间后，当IO返回结果时，再通知CPU进行处理。

**阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型，因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的（注意，这句话的重点是由应用程序完成而不是由内核完成的）**

我们可能会认为信号驱动也像是异步I/O，毕竟它可以做自己的事情，等信号来了再处理。但是，异步 I/O 与信号驱动 I/O 的区别在于，**异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。**

## 两种高效的事件处理模式

服务器程序通常需要处理三类事件：**I/O事件、信号及定时事件。**

了解Reactor和Proactor事件处理模式，同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。

### Reactor模式

**特点**

主线程（I/O处理单元）只负责监听文件描述符是否有事件发生，有则通知工作线程（逻辑单元）

读写数据，接受新的连接以及处理客户请求都在工作线程完成（处理IO事件由应用程序完成而不是内核，故为同步I/O模型）

**使用同步I/O模型实现Reactor模式**

- 主线程往epoll内核事件种注册socket上的读就绪事件
- 主线程调用epoll_wait等待socket上有数据可读
- 当socket上有数据可读时，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列
- 睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
- 主线程调用eoll_wait等待socket可写
- 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
- 睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015230341151.png" alt="image-20211015230341151" style="zoom: 150%;" />

工作线程从请求队列中取出事件后，将根据事件的类型来决定如何处理它，没必要区分所谓的“读工作线程”和“写工作线程”

### Proactor模式

与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。

**使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模式的工作流程**



<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015231459562.png" alt="image-20211015231459562" style="zoom:150%;" />

- 主线程调用aio_read函数向内核注册socket上的读完成事件并 告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。
- 主线程继续处理其他逻辑。
- 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 
- 应用程序预先定义好的信号处理函数选择一个工作线程来处理 客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓】冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。
- 主线程继续处理其他逻辑。 
- 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 
- 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

**模拟Proactor模式**

其原理是主线程执行数据读写，读写完成之后，主线程向工作线程通知这一完成事件，那么从工作线程角度看，他们直接获得了数据读写的结果，就和内核通知其数据读写完成一样，接下来工作现场做逻辑处理即可

- 主线程往epoll内核事件表中注册socket上的读就绪事件。 
- 主线程调用epoll_wait等待socket上有数据可读。
- 当socket上有数据可读时，epoll_wait通知主线程。主线程从 socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。
- 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并 处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。
- 主线程调用epoll_wait等待socket可写。
- 当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。

![image-20211018161304770](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018161304770.png)

## 两种高效的并发模式

并发编程同时执行任务

如果程序是计算密集型的，并发编程没有又是，反而会由于任务的切换使其效率降低

如果程序是IO密集型的，经常读写文件等，由于I/O操作会阻塞，或者读写数据耗时，所以程序会耗费大量时间，这个时候并发模型就很好了，可以在I/O操作时去干别的事情

- 并发编程主要有多进程和多线程两种方法

- 并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的办法
- 服务器主要有两种并发编程模式
  - 半同步/半异步模式
  - 领导者/追随者模式

### 半同步/半异步模式

我们需要区分以下I/O和并发中同步异步的概念

**I/O：**

- I/O中同步异步区分是内核向应用程序通知的是何种I/O事件以及该由谁来完成I/O读写

**并发：**

- 同步指的是程序完全按照代码序列的顺序执行

- 异步指的是程序的执行需要由系统事件（中断、信号等）来驱动

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018162312686.png" alt="image-20211018162312686" style="zoom: 67%;" />

**按照同步方式运行的线程称为同步线程，异步方式的线程称为异步线程**

- 异步线程的执行效率高，实时性强，但编写复杂

- 同步线程效率较低，实时性较差，但逻辑简单

**半同步/半异步模式**

- 同步线程用于处理客户端
- 异步线程用于处理I/O事件

> 比如这个图片

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211015230341151.png" alt="image-20211015230341151" style="zoom: 150%;" />

异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

<img src="https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018162729338.png" alt="image-20211018162729338" style="zoom:67%;" />

**我们结合之前，考虑两种事件处理模式和几种I/O模型，则半同步/半异步模式存在多种变体**

**半同步/半反应堆模式**

![image-20211018170345480](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018170345480.png)

主线程充当异步线程，它负责监听所有 socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。

如果连接socket上有读写事件发生， 即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接 socket插入请求队列中。所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务

**主线程插入请求队列中的任务是就绪的连接socket。这 说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：**

它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。

实际上，半同步/半反应堆模式也可以使用模拟的Proactor事件处理模式，即由主线程来完成数据的读写。在这种情况下，主线程一般会将应用程序数据、 任务类型等信息封装为一个任务对象，然后将其（或者指向该任务对 象的一个指针）插入请求队列。工作线程从请求队列中取得任务对象之后，即可直接处理之，而无须执行读写操作了。

**半同步/半反应堆模式存缺点**

- 主线程和工作线程共享请求队列。主线程往请求队列中添加任 务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间
- 每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户 端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题， 则工作线程的切换也将耗费大量CPU时间

**高效的半同步/半异步模式**

![image-20211018170800420](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018170800420.png)

图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工 作线程来处理，直到客户关闭连接。主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测 到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表 中。 

可见，图8-11中，每个线程（主线程和工作线程）都维持自己的事 件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同 步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义 上的半同步/半异步模式。

### 领导者/追随者模式

领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式

**包含以下几个组件**

- 句柄集
  - 句柄：通常就是我们说的文件描述符
  - 句柄集管理众多句柄（epoll_event），它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。
  - 领导者则调用绑定到Handle上的事件处理器来处理事件
- 线程集
  - 这个组件是所有工作线程（包括领导者线程和追随者线程）的管理者
  - 它负责各线程之间的同步，以及新领导者线程的推选
  - 必定处于三种状态之一
    - Leader：**线程当前处于领导者身份，负责等待句柄集上的I/O事件。** 
    - Processing：线**程正在处理事件。领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者**；也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。当处于Processing状态的线程处理 完事件之后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接转变为追随者。 
    - Follower：**线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者**，也可能被当前的领导者指定来处理新的任务。
    - ![image-20211018173918452](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018173918452.png)
- 事件处理器和具体的事件处理器
  - 事件处理器通常包含一个或多个回调函数handle_event
  - 事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生 类

![image-20211018224227597](https://syz-picture.oss-cn-shenzhen.aliyuncs.com/image-20211018224227597.png)

由于领导者线程自己监听I/O事件并处理客户请求，因而领导者/追 随者模式不需要在线程之间传递任何额外的数据，也无须像半同步/半 反应堆模式那样在线程之间同步对请求队列的访问。但领导者/追随者 的一个明显缺点是仅支持一个事件源集合，因此也无法像图8-11所示的 那样，让每个工作线程独立地管理多个客户连接。

## 有限状态机

逻辑单元内部的一种高效编程方法：有限状态机。

有的应用层协议头部包含数据包类型字段，每种类型可以映射为 逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑

```C
STATE_MACHINE(Package_pack)
{
    PackageType_type=_pack.GetType();
    switch(_type)
    {
        case type_A:
            process_package_A(_pack);
            break;
        case type_B:
            process_package_B(_pack);
            break;
    }
}
```

该状态机的每个状态都是相互独立的（switch分类），即状态之间没有相互转移。状态之间的转移是需要状态机**内部驱动**的

```C
{
    // 状态机的当前状态记录在cur_State
    State cur_State = type_A;
    // 在一趟循环过程中，状态机先通过getNewPackage方法获得一个新的数据包，
    // 然后根据cur_State变量的值判断如何处理该数据包
    while(cur_State != type_C)
    {
        Package _pack = getNewPackage();
        switch(cur_State)
        {
            case type_A:
                process_package_state_A(_pack);
                // 数据包处理完之后，状态机通过给cur_State变量传递目标状态值来实现状态转移
                cur_State = type_B;
                break;
            case type_B:
                process_package_state_B(_pack);
                // 数据包处理完之后，状态机通过给cur_State变量传递目标状态值来实现状态转移
                cur_State = type_C;
                break;
        }
        // 状态机进入下一趟循环时，它将执行新的状态对应的逻辑
    }
}
```

**有限状态机应用实例**

> HTTP请求的读取和分 析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长 度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议 头部。但HTTP协议并未提供这样的头部长度字段，并且其头部长度变 化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， 我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回车换行符（＜CR＞＜LF＞）。如果一次读操作没有读入HTTP请求的整个头部，即没有遇到空行，那么我们必须等待客户继续写数据并再 次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP 请求头部的分析（记住，空行前面还有请求行和头部域），以提高解析HTTP请求的效率。

- [(140条消息) 什么是状态机？_pingxiaozhao的博客-CSDN博客](https://blog.csdn.net/pingxiaozhao/article/details/109239311?ops_request_misc=%7B%22request%5Fid%22%3A%22163547886216780255232341%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=163547886216780255232341&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-109239311.pc_search_result_hbase_insert&utm_term=什么叫做状态机&spm=1018.2226.3001.4187)



## 提高服务器性能的其它建议



## 参考

《Linux高性能服务器编程》

